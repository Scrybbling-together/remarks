from typing import List, Dict

import yaml
from rmscene.scene_items import GlyphRange, ParagraphStyle
from rmscene.text import Paragraph

from remarks.Document import Document


def render(paragraph: Paragraph):
    text = ""
    for st in paragraph.contents:
        st_text = str(st)
        if st.properties['font-weight'] == "bold":
            st_text = f"**{st_text}**"
        if st.properties['font-style'] == "italic":
            st_text = f"_{st_text}_"
        text += st_text

    return text


class RMPage:
    def __init__(self):
        self.highlights: List[GlyphRange] = []
        self.tags: List[str] = []
        self.text: None | list[Paragraph] = None


def _merge_highlight_texts(h1: GlyphRange, h2: GlyphRange, distance: int):
    """
    Merge the text of two highlights based on their relative positions.

    Args:
        h1: The first highlight (comes earlier in the text)
        h2: The second highlight
        distance: The calculated distance between the highlights

    Returns:
        str: The merged text
    """
    text = ""

    # Case 1: B starts after A ends (positive distance)
    if distance > 0:
        # We need to add the gap characters
        # Since we don't have access to the original text, use placeholder for the gap
        gap = " " * distance  # Using spaces as placeholder for the gap
        text = h1.text + gap + h2.text

    # Case 2: B starts before A ends (overlap)
    else:
        # Calculate the overlap amount
        overlap = -distance

        # The first part is all of A's text
        merged_first_part = h1.text

        # For the second part, we need to skip the overlapped characters from B
        # This assumes the overlapped text is identical in both highlights
        merged_second_part = h2.text[overlap:] if overlap < len(h2.text) else ""

        text = merged_first_part + merged_second_part

    return " ".join(text.split())


def calculate_highlight_distance(h1, h2):
    if h1.start > h2.start:
        h1, h2 = h2, h1
    end_of_h1 = h1.start + h1.length
    distance = h2.start - end_of_h1

    if h1.color != h2.color:
        return float('inf')

    return distance, end_of_h1, h1, h2


class ObsidianMarkdownFile:
    def __init__(self, document: Document):
        self.pages: Dict[int, RMPage] = {}
        self.document = document

    def save(self, location: str):
        frontmatter = {}
        content = ""
        if self.document.rm_tags:
            frontmatter["tags"] = list(
                map(lambda tag: f"#remarkable/{tag}", self.document.rm_tags)
            )

        if len(frontmatter) > 0:
            frontmatter_md = f"""---
{yaml.dump(frontmatter, indent=2)}---

"""
            content += frontmatter_md

        content += f"""# {self.document.name}

> [!WARNING] **Do not modify** this file
> This file is automatically generated by Scrybble and will be overwritten whenever this file in synchronized.
> Treat it as a reference.
"""

        if self.pages:
            content += """
## Pages\n\n"""
            for index, page in sorted(self.pages.items()):
                highlights = page.highlights
                content += f"""### [[{self.document.name}.pdf#page={index + 1}|{self.document.name}, page {index + 1}]]
"""

                if page.highlights:
                    content += f"""
#### Highlights
                   
"""
                    for highlight in highlights:
                        content += f"> {highlight.text}\n"

                if page.text:
                    content += f"""
#### Typed text
"""
                    for paragraph in page.text:
                        paragraph_content = render(paragraph)
                        if paragraph.style.value == ParagraphStyle.PLAIN:
                            content += f"\n{paragraph_content}\n"
                        elif paragraph.style.value == ParagraphStyle.BOLD:
                            content += f"\n###### {paragraph_content}\n"
                        elif paragraph.style.value == ParagraphStyle.HEADING:
                            content += f"\n##### {paragraph_content}\n"
                        elif paragraph.style.value == ParagraphStyle.BULLET or paragraph.style.value == ParagraphStyle.BULLET2:
                            content += f"- {paragraph_content}\n"
                        elif paragraph.style.value == ParagraphStyle.CHECKBOX:
                            content += f"- [ ] {paragraph_content}\n"
                        elif paragraph.style.value == ParagraphStyle.CHECKBOX_CHECKED:
                            content += f"- [x] {paragraph_content}\n"

        # don't write if the file is empty
        if self.document.rm_tags or self.pages:
            with open(f"{location} _obsidian.md", "w") as f:
                f.write(content)

    def add_highlights(
        self, page_idx: int, highlights: List[GlyphRange]
    ):
        if not highlights:
            return

        # Define the maximum gap threshold for merging
        max_gap_threshold = 3  # Adjust this based on your data

        # Start with all highlights as separate items
        merged_highlights = highlights.copy()

        # Continue until no more changes
        while True:
            # Sort by starting position
            merged_highlights.sort(key=lambda h: h.start)

            # Flag to track if any merges happened
            merged_any = False

            # Check all pairs for possible merges
            i = 0
            while i < len(merged_highlights) - 1:
                j = i + 1
                while j < len(merged_highlights):
                    h1 = merged_highlights[i]
                    h2 = merged_highlights[j]

                    # Calculate distance (ensuring A comes before B)
                    distance, end_of_h1, h1, h2 = calculate_highlight_distance(h1, h2)

                    # If they should be merged
                    if distance <= max_gap_threshold:
                        # Create merged highlight
                        new_start = min(h1.start, h2.start)
                        new_end = max(end_of_h1, h2.start + h2.length)
                        new_length = new_end - new_start

                        # Merge text
                        new_text =_merge_highlight_texts(h1, h2, distance)

                        # Create new highlight
                        merged_highlight = GlyphRange(
                            start=new_start,
                            length=new_length,
                            text=new_text,
                            color=h1.color,
                            rectangles=h1.rectangles + h2.rectangles
                        )

                        # Replace A with merged highlight and remove B
                        merged_highlights[i] = merged_highlight
                        merged_highlights.pop(j)

                        merged_any = True
                        # Don't increment j since we removed an element
                    else:
                        j += 1

                i += 1

            # If no merges happened, we're done
            if not merged_any:
                break

        if page_idx not in self.pages:
            page = RMPage()
            self.pages[page_idx] = page
        else:
            page = self.pages[page_idx]
        page.highlights = merged_highlights

    def add_text(self, page_idx: int, text):
        if not text:
            return
        if page_idx not in self.pages:
            page = RMPage()
            self.pages[page_idx] = page
        else:
            page = self.pages[page_idx]

        page.text = text["text"].contents
